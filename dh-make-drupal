#!/usr/bin/ruby

# dh-make-drupal
#
# Creates Debian packages from Drupal projects (modules, themes, translations).
# Copyright (C) 2009 Gunnar Wolf <gwolf@gwolf.org>
# Instituto de Investigaciones Económicas - UNAM
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require 'commandline'
require 'digest/md5'
require 'etc'
require 'fileutils'
require 'hpricot'
require 'open-uri'
require 'singleton'
require 'tmpdir'
require 'yaml'


class App < CommandLine::Application
  def initialize
    version '0.4'
    author 'Gunnar Wolf'
    copyright 'Gunnar Wolf <gwolf@gwolf.org>, IIEc-UNAM 2009'
    short_description 'Builds a Debian package for the requested Drupal project'
    long_description <<DESC
The purpose of this program is to generate Debian packages for any Drupal
projects (that is, modules, themes or translations). 

Given that Drupal developers publish their work through the main Drupal 
site (http://drupal.org), this program fetches the information for the
latest available versions (for the right Drupal release, and with the 
specified stability level), and prepares a Debian package from it.

This Debian package can be locally installed using 'dpkg', or uploaded to your
Apt repository.

Keep in mind that this package only goes as far as it can, being an automated 
tool. The generated packages will probably require verification/tweaking to
be of production quality.

This program has been inspired -and named in a similar fashion to- Debian's
pkg-perl group's dh-make-perl.
DESC
    synopsis '[options] project_name'
    statuses = DrupalProject::Release::statuses
    projtypes = DrupalProject::ProjType::Known.keys.sort

    option(:names => %w(-d --drupal-version), 
           :opt_found => get_args,
           :opt_not_found => 6,
           :opt_description => 'Drupal version',
           :arg_description => 'version')
    option(:flag, :names => %w(-r --report-only),
           :opt_description => "Check only for project availability, " +
           "don't download or perform any other actions locally. Implies -D.")
    option(:flag, :names => %w(-f --force),
           :opt_description  => 'Proceed even if this will overwrite ' +
           'currently existing files')
    option(:names => %w(--debug),
           :opt_found => get_args,
           :opt_not_found => 1,
           :opt_description => 'Debug level for generated messages ' +
           '(0=highest, 5=lowest)',
           :arg_description => 'level')
    option(:names => %w(-s --min-status),
           :opt_found => get_args,
           :opt_not_found => statuses[0],
           :opt_description => ('Minimum status to consider for packaging. ' +
                                'Accepted values: %s. Defaults to %s.' %
                                [ statuses.map {|s| "'#{s}'"}.join(', '),
                                  statuses[0]]))
    option(:flag, :names => %w(-D --dont-debianize),
           :opt_description => 'Do not attempt to debianize the project, ' +
           'only download the tarball')
    option(:flag, :names => %w(-b --no-build),
           :opt_description => 'Prepare the debianized directory, but omit ' +
           'the actual package build process. This option is incompatible ' +
           'with either -D and -r.')
    option(:names => %w(--build-switches),
           :opt_found => get_args,
           :opt_not_found => '-us -uc',
           :opt_description => 'Switches to pass to dpkg-buildpackage. ' +
           'Defaults to "-us -uc" (do not sign the generated package). ' +
           'In order not to give any switches, specify an empty quoted ' +
           'string (i.e. --build-switches=\'\').')
    option(:names => %w(-t --tarball),
           :opt_found => get_args,
           :opt_description => 'Use the specified tarball as the original ' +
           'project tar.gz, don\'t look for any other available versions ' +
           'and don\'t download from the Drupal website. This will require ' +
           'you also to provide a project version number with -V and the ' +
           'project type with -T',
           :arg_description => 'tarball'
           )
    option(:names => %w(-T --proj-type),
           :opt_found => get_args,
           :opt_description => 'Type of project we are packaging. This ' +
           'option is only meaningful when working on a local tarball (-t), ' +
           'and will be ignored otherwise. Accepted values: %s. Defaults ' +
           'to %s.' % [ projtypes, projtypes[0] ],
           :opt_not_found => projtypes[0],
           :arg_description => 'projtype'
           )
    option(:names => %w(-V --proj-version),
           :opt_found => get_args,
           :opt_description => 'Provide a project version number. This ' +
           'option is only meaningful when working on a local tarball (-t), ' +
           'and will be ignored otherwise',
           :arg_description => 'version'
           )
    option(:flag, :names => %w(-m --mangle-version),
           :opt_description => 'Debian versioning logic includes the «~» ' +
           'character meaning «anything below» the preceding version ' +
           'number. This is most useful when dealing with pre-release ' +
           'qualificators (in order, 1.x-dev, 1.0-alpha1, 1.0-beta, 1.0rc3). '+
           'dh-make-drupal will try to recognize such patterns and mangle ' +
           'them so they sort correctly in Debian (and so that when a ' +
           'stable version is released it appears as higher - For the above ' +
           'mentioned version numbers, they would result in 1~~dev, ' +
           '1.0~alpha1, 1.0~beta, 1.0~rc3). You can use this switch to tell ' +
           'dh-make-drupal to omit this mangling.')
    option :version, :names => %w(-v --version)
    option :help, :names => %w(-h --help)

    expected_args :project
  end

  def main
    o = DrupalProject::Options
    log = DrupalProject::Logger.instance
    log.level = opt['--debug']

    o.d_ver = opt['-d']
    o.min_status = opt['-s']
    o.force_overwrite = opt['-f']
    o.debug = opt['--debug'] 
    o.report_only = opt['-r']
    o.debianize = ! opt['-D']
    o.skip_build = opt['-b']
    o.switches = opt['--build-switches']
    o.tarball = opt['-t']
    o.proj_version = opt['-V']
    o.proj_type = opt['-T']
    o.mangle_version = ! opt['-m']

    begin
      if o.tarball
        begin
          down = DrupalProject::Downloader.mock(@project, o.d_ver, 
                                                o.tarball, o.proj_version)
        rescue DrupalProject::Downloader::LackingMock
          log.error 'Missing information: Project name, tarball and project ' +
            'version are required when working with a local tarball.'
          exit 1
        rescue Errno::ENOENT
          log.error 'Specified tarball (%s) does not exist, cannot continue' %
            o.tarball
          exit 1
        end
      else
        down = DrupalProject::Downloader.new(@project, o.d_ver, o.min_status)
        down.download 
      end

      deb = DrupalProject::DebianPackager.new(down) 
      deb.build_structure
      deb.build_package(o.switches)
    rescue DrupalProject::SkipRequested
      # All fine, nothing to see, please move along
    end
  end
end

module DrupalProject
  class SkipRequested < Exception; end
  # This class acts basically as an universally available hash, with
  # some syntactic sugar. Calling any method ending in '=' will assign
  # the specified value to that key, and calling any method not ending
  # in '=' will give back the value. For extra bonus points, logs
  # options changes if so requested.
  class Options
    @@opts = {}
    def self.method_missing(meth,*args)
      attr = meth.to_s
      if attr.gsub! /\=$/,''
        Logger.instance.debug("Setting configuration key «%s» to «%s»" % 
                              [attr, args.to_s] )
        @@opts[attr] = args.length<2 ? args[0] : args
      end
      @@opts[attr]
    end
  end

  # Finds the needed information for a given project's files
  # (corresponding to the specified Drupal release and minimum
  # stability level indicated), and allows for downloading it
  class Downloader
    class LackingMock < Exception; end
    attr_accessor :release, :project, :d_ver, :filename
    # Fetches the needed information from the Drupal website. The
    # project name is specified as the first parameter; the Drupal
    # version to fetch the project for is specified as the second
    # parameter (defaulting to 6); the third parameter is the minimum
    # status (as reported by the author) to download - It can be (in
    # decreasing order) :recommended, :supported or :developer,
    # defaulting to :recommended.
    def initialize(project, d_ver=6, status=:recommended)
      @project = project
      @d_ver = d_ver
      fetch_info(status) unless status == :mock
    end

    def self.mock(project, d_ver, tarball, proj_ver)
      raise LackingMock unless project and d_ver and tarball and proj_ver
      raise Errno::ENOENT unless File.exists? tarball

      down = self.new(project, d_ver, :mock)
      down.filename = tarball
      down.release = rel = Release.new

      rel.project = Project.new(project)
      rel.project.p_type = ProjType.new(Options.proj_type)
      rel.project.descr = 'Generated from a local file - Sorry, cannot ' +
        'even fetch a proper description!'
      rel.drupal_version = d_ver
      rel.version = proj_ver

      Logger.instance.debug 'Mocking download information for local file: ' +
        down.to_yaml

      down
    end

    # A #Downloader instantiation only gets the available
    # information. To actually download the file, call #download. The
    # file will be saved under the name specified by the #Release
    # object. Note the filename will follow the regular Debian scheme
    # (i.e. drupal6-og_1.1.orig.tar.gz), not the usual Drupal scheme
    # (og-6.x-1.1.tar.gz).
    def download
      if Options.report_only
        Logger.instance.info 'Reporting only, as requested in the command line'
        puts "Highest available version for %s (Drupal %s, status >= %s):" %
          [@project, @d_ver, @status]
        puts "Project page: %s" % release.project.url
        puts "Release: %s (%s)" % [release.version, release.sym_status]
        puts "Download URL: %s)" % release.url
        raise SkipRequested
      end
      @release.save_file
      @filename = release.dest_file
    end

    private
    def fetch_info(status)
      Logger.instance.debug(("Preparing package for '%s' for Drupal %s, "+
                             "status >= %s") % [project, d_ver, status])
      @release = DrupalProject::VersionsList.for(@project).
        choose(d_ver, status)
      Logger.instance.info "Found %s version %s (status: %s)" % 
        [@release.project, @release.version, @release.sym_status]
      Logger.instance.debug "Download URL: #{release.url}"
    end
  end

  class DebianPackager
    def initialize(down)
      if ! Options.debianize
        Logger.instance.debug('Skipping Debian package creation as ' +
                              'requested at command line')
        raise SkipRequested
      end

      Logger.instance.debug 'Starting Debian package creation'
      @d_ver = down.d_ver
      @release = down.release
      @project = @release.project
      @version = @release.version
      @author = @project.author
      @maint_name = ENV['DEBFULLNAME'] || Etc::getpwuid.gecos.gsub(/,+$/, '')
      @maint_mail = ENV['DEBEMAIL'] || ENV['EMAIL']
      @pkgname = PackageName.for(@project.name, @project.p_type, @d_ver)
      @tarball = down.filename
      @instdir = '%s-%s' % [@pkgname, @release.version]
      @builddir = '/usr/share/drupal%s' % @d_ver
      if @project.p_type.ck_tar_in_dir?
        @builddir = File.join(@builddir, @project.p_type.dir, @project.name )
      end

      ck_orig_tarball
      Logger.instance.info 'Debian package name: %s' % @pkgname
    end

    # Unpacks the downloaded tarball and creates the Debian package
    # structure in it
    def build_structure
      setup_directory
      setup_changelog
      setup_compat
      setup_control
      setup_copyright
      setup_dirs
      setup_watch
      setup_rules
    end

    # Builds the Debian package from the created directory structure
    def build_package(switches)
      if Options.skip_build
        Logger.instance.debug('Skipping Debian package build as requested at ' +
                              'command line')
        raise SkipRequested
      end
      if ! File.exists? '/usr/bin/dpkg-buildpackage'
        Logger.instance.error 'dpkg-buildpackage not found - Cannot build ' +
          'the generated package.'
        exit 1
      end

      cmdline = '/usr/bin/dpkg-buildpackage %s' % switches
      Logger.instance.info 'Starting Debian package build'
      Logger.instance.debug 'Invoking external command: %s' % cmdline

      system('cd %s && %s 2>&1' % [@instdir, cmdline])
    end

    private
    # Checks if the original tarball looks like a sane Drupal project
    # file, and populate @filelist with the relevant
    # information. Raises a RuntimeError if it does not look right.
    def ck_orig_tarball
      @filelist = []

      @filelist = IO.popen('tar tzf %s' % @tarball).readlines.map do |file|
        if @project.p_type.ck_tar_in_dir?
          # Project types which ship their whole contents inside a
          # directory with the same name as themselves (modules,
          # themes): Refuse to continue if there are files I don't know
          # how to handle (i.e. are not in the expected place)
          raise RuntimeError,('Downloaded file %s has an unexpected '+
                              'directory hierarchy (%s) - Aborting.') %
            [@tarball, file] unless file.gsub!(/^#{@project.name}\//, '')
        end
        file.gsub(/\n$/, '')
      end.reject {|file| file.empty?}
      Logger.instance.debug('Original tarball verified - %s files included' %
                            @filelist.size)
    end

    # Sets up the directory for starting the Debian packaging
    def setup_directory
      curdir = Dir.pwd
      FileUtils.rm_r(@instdir) if Options.force_overwrite and
        File.exists?(@instdir)
      Dir.mkdir(@instdir)
      Dir.mkdir(File.join(@instdir, 'debian'))

      Dir.mktmpdir do |tmpdir|
        system("cd #{tmpdir}; tar xzf #{File.join(curdir, @tarball)}")

        move_from = (@project.p_type.ck_tar_in_dir? ?
                     File.join(tmpdir, @project.name) : tmpdir)

        Dir.open(move_from).entries.reject { |e| 
          ['.','..'].include? e 
        }.each {|f|
          FileUtils.mv(File.join(move_from,f), @instdir)
        }
      end
    end

    # Creates the debian/changelog file
    def setup_changelog
      timestamp = Time.now.strftime '%a, %d %b %Y %H:%M:%S %z'
      deb_ver = '%s-1' % @release.version
      distr = 'unstable'
      
      entry = ("%s (%s) %s; urgency=low\n\n" % [@pkgname, deb_ver, distr]) +
        "  * Initial release\n\n" +
        (" -- %s <%s>  %s" % [@maint_name, @maint_mail, timestamp] )

      put_in_file 'changelog', entry
    end

    # Creates the debian/compat file
    def setup_compat
      put_in_file 'compat', '5'
    end

    # Creates the debian/watch file
    def setup_watch
      res = ['version=3',
             ( 'http://drupal.org/project/%s .*/%s-%s.x-(\d[\d_.]+)\.tar\.gz' %
               [@project.name, @project.name, @d_ver] ) ].join("\n")
      put_in_file 'watch', res
    end

    # Creates the debian/copyright file
    def setup_copyright
      res = ['-=-=-=- WARNING -=-=-=-',
             'This file has been autogenerated by dh-make-drupal.', 
             '',
             'While this program does its best to achieve proper results,',
             'copyright information is a very sensible topic which REQUIRES',
             'HUMAN VALIDATION. Please make sure that this information is',
             'correct.',
             '-=-=-=-=-=-=-=-=-=-=-=-'
            ]

      if @project.author
        start_yr = @project.creation.year
        release_yr = @release.date.year
        years = (start_yr == release_yr) ? start_yr : 
          '%s - %s' % [start_yr, release_yr]
        res << 'Copyright %s, %s (%s)' %
          [ years, @project.author.name, @project.author.info_url ] << ''
        Logger.instance.debug 'Author copyright information found: ' + 
          res.join("\n")
      else
        Logger.instance.debug 'Author copyright information not found'
      end

      # Canonically, Drupal modules include LICENSE.txt. Even more,
      # canonically it is the GPLv2 - For further joy, it's usually
      # the exact same file! :-)
      if license = File.join(@instdir, find_license[0])
        data = File.read(license)
        if Digest::MD5.hexdigest(data) == "998ed0c116c0cebfcd9b2107b0d82973"
          res << 'This package is licensed under the GNU General Public ' <<
            'License (GPL) version 2.' << '' <<
            'On Debian GNU/Linux systems, the complete text of the GNU ' <<
            'General Public License can be found in:' << '' <<
            '/usr/share/common-licenses/GPL-2'
          Logger.instance.debug 'Upstream ships the canonical GPLv2'
        else
          res << data
          Logger.instance.info('Cannot automatically determine the chosen ' +
                               'license - Please check by hand')
        end
      else
        Logger.instance.warn('No license file found in distribution, cannot ' +
                             'guess copyright information - Please check by ' +
                             'hand.')
        res << 'Copyright information could not be automatically ' +
          'retreived'
      end

      put_in_file 'copyright', res.join("\n")
    end

    # Creates the debian/control file
    def setup_control
      depends = Dependencies.new(@release, @instdir)
      put_in_file 'control', ['Source: %s' % @pkgname,
                              'Section: web',
                              'Priority: extra',
                              'Maintainer: %s <%s>' % [@maint_name, 
                                                       @maint_mail],
                              'Build-Depends: debhelper (>> 5.0.0)',
                              'Standards-Version: 3.8.0',
                              'Homepage: %s' % @project.url,
                              '',
                              'Package: %s' % @pkgname,
                              'Architecture: all',
                              'Depends: %s' % depends.get,
                              'Description: %s' % short_descr,
                              long_descr].join("\n")
    end

    # Creates the debian/rules file
    def setup_rules
      res = ['#!/usr/bin/make -f',
             '# This debian/rules file has been autogenerated by',
             '# dh-make-drupal. It is based on the debhelper sample file,',
             '# GNU copyright 1997 to 1999 by Joey Hess.', 
             '',
             '# Uncomment this to turn on verbose mode',
             '#export DH_VERBOSE=1',
             'DESTDIR = $(CURDIR)/debian/%s' % @pkgname, 
             'BUILDDIR = $(DESTDIR)/%s' % @builddir,
             ''
            ]

      targets = [['clean', '', %w(dh_testdir dh_testroot dh_clean)],
                 ['build'],
                 ['install', '', 
                  ['dh_testdir', 'dh_testroot', 'dh_clean -k', 
                   'dh_installdirs', 'dh_installdocs %s' % find_docs.join(' '),
                   'cp -r %s $(BUILDDIR)' % files_to_install.join(' '),
                   'find $(BUILDDIR) -type f |xargs chmod 0644'
                  ]], 
                 ['binary-arch'],
                 ['binary-indep', 'install', 
                  %w(dh_testdir dh_testroot dh_installdocs dh_installman) +
                  ['dh_installchangelogs %s' % find_changelog.join(' ')] +
                  %w(dh_compress dh_fixperms dh_installdeb
                     dh_gencontrol dh_md5sums dh_builddeb)],
                 ['binary', 'binary-indep binary-arch'],
                 ['.PHONY', 
                  'build clean binary-indep binary-arch binary install']
                ]

      targets.each {|t| res << RulesTarget.new(*t).to_s}

      put_in_file 'rules', res.join("\n")
      FileUtils.chmod(0755, File.join(@instdir, 'debian', 'rules'))
    end

    # Creates the debian/dirs file
    def setup_dirs
      subdirs = subdirs_for(@instdir).reject {|d| d =~ /^#{@instdir}.debian/}

      dirs = [@builddir, subdirs.map {|d| File.join(@builddir,d)}].flatten
      put_in_file 'dirs', dirs.join("\n")
    end

    # Builds a short description for the package
    def short_descr
      '%s %s for Drupal %s' % [@project.name, @project.p_type.human.downcase,
                               @d_ver]
    end

    # Gets the long description for the package
    def long_descr
      ( "%s\n\nThis is an auto-generated description made by dh-make-drupal." %
        @project.descr ).word_wrap.prefix
    end

    # Returns the list of files and directories at the top level of
    # this project's hierarchy
    def files_at_root
      @filelist.map {|f| f.gsub /\/.*/, ''}.uniq
    end

    # Returns the changelog's filename, if one is found
    def find_changelog
      files_at_root.select {|f| f =~ /^(changelog|changes)/i}
    end

    # Returns the license's filename, if one is found
    def find_license
      files_at_root.select {|f| f =~ /license/i}
    end

    # Returns the project's documentation files, if found - All the
    # .txt files, excluding changelog and license
    def find_docs
      files_at_root.select {|f| f =~ /\.txt$/} - find_changelog - find_license
    end

    # The list of files to copy to the debianized package
    def files_to_install
      files_at_root - find_changelog - find_license - find_docs
    end

    # Creates the specified file inside the debian/ directory, with
    # the contents received as the second parameter
    def put_in_file(filename, data)
      File.open(File.join(@instdir, 'debian', filename), 'w') do |f|
        f.puts data
      end
    end

    def subdirs_for(dir)
      res=[dir]
      ignore = ['.', '..']
      Dir.open(dir).each do |subdir|
        full = File.join(dir,subdir)
        next if ignore.include?(subdir)
        next unless FileTest.directory?(full)
        res << subdirs_for(full)
      end
      res.flatten.uniq
    end
  end

  class RulesTarget 
    attr_accessor :name, :cmds, :depends
    def initialize(name, depends='', cmds=[])
      @name = name
      @depends = depends
      @cmds = cmds
    end

    def <<(elem)
      @cmds << elem
    end

    def to_s
      res = ['%s: %s' % [@name, @depends]]
      return res[0] + ';' if @cmds.empty? and @depends.empty?
      @cmds.each {|cmd| res << "\t%s" % cmd}
      res << ''
      return res.join("\n")
    end
  end

  # Generates the package name for a given project name and type
  # (#ProjType), for the specified Drupal version.
  class PackageName
    def self.for(name, type, d_ver)
      ('drupal%s-%s-%s' % [d_ver, type.name_part, name]).gsub(/_/, '-')
    end
  end

  # Dependency-related information is (currently?) only expressed in
  # the {module}.info file inside the tarball and can thus only be
  # gathered once the module is unpacked.
  # 
  # All dependencies are expected to be on modules. If this
  # contradicts reality... I'll be glad to change it, I guess :)
  class Dependencies
    class Irrelevant < Exception; end
    # Core Drupal dependencies were gathered by:
    #
    # $ dpkg -L drupal5 | grep modules |cut -d / -f 6|sort|uniq
    # (and equivalent for drupal6).
    CoreDrupalModules = {'5' => %w(aggregator block blog blogapi book color 
        comment contact drupal filter forum help legacy locale menu node path 
        ping poll profile search statistics system taxonomy throttle tracker 
        upload user watchdog),
      '6' => %w(aggregator block blog blogapi book color comment contact dblog 
        filter forum help locale menu node openid path php ping poll profile 
        search statistics syslog system taxonomy throttle tracker translation 
        trigger update upload user)}

    # Builds the dependency lists from the information declared in the
    # project's .info file
    def initialize(release, basedir)
      @d_ver = release.drupal_version
      @depends = ['${misc:Depends}', 'drupal%s' % @d_ver]
      
      begin
        filename = File.join(basedir, '%s.info' % release.project.name)
        File.open(filename).lines.each { |info_fh| parse_depends(info_fh) }
      rescue Errno::EACCES, Errno::ENOENT
        Logger.instance.warn(('Expected .info file (%s) not found or not ' +
                              'readable. Cannot fetch dependency ' +
                              'information.') % filename)
      end
    end

    # Fetches the list of Debian package dependencies. It is handed
    # back as a string, ready to put straight in the 'Depends' field.
    def get
      @depends.join(', ')
    end

    private
    # Parse the dependencies declared in the .info file; skip those
    # which are part of the core Drupal installation
    def parse_depends(line)
      begin
        raise Irrelevant unless line and
          line =~ /dependencies\[.*\]\s*=\s*(.*)\n?/
        dep = $1
        begin
          if CoreDrupalModules[@d_ver].include?(dep)
            Logger.instance.debug(('Declared dependency %s is part of ' +
                                   'Drupal %s core - Skipping') % 
                                  [dep, @d_ver])
            raise Irrelevant
          end
        rescue NoMethodError
          Logger.instance.warn(('No list of core modules available for ' +
                                'Drupal version %s - Cannot infer what ' +
                                'to exclude, including everything.') % @d_ver)
        end
        dep_pkg = PackageName.for(dep, ProjType.new('Modules'), @d_ver)
        Logger.instance.info('Adding dependency on %s' % dep_pkg)
        @depends << dep_pkg
      rescue Irrelevant
        # Just skip it, it's irrelevant!
      end
    end
  end

  # Stores the basic settings on how to treat the different kind of
  # projects available through the Drupal website.
  #
  # Currently we are only dealing with modules, themes and
  # translations. The other available types (theme engines,
  # installation profiles and drupal project) are outside our scope -
  # although for some of them, this code could be trivially expanded.
  class ProjType
    Known = {'Modules' => {:human => 'Module', 
        :name_part => 'mod',
        :ck_tar_in_dir => true,
        :dir => 'modules'
      },
      'Themes' => {:human => 'Theme', 
        :name_part => 'thm',
        :ck_tar_in_dir => true,
        :dir => 'themes'},
      'Translations' => {:human => 'Translation',
        :name_part => 'trans',
        :ck_tar_in_dir => false,
        :dir => ''}
    }

    # Takes the type string (as reported by each project in the
    # 'Breadcrumbs' of its project page). If the key is not defined,
    # raises a NameError exception.
    def initialize(key)
      raise NameError, "Unknown project type #{key}" unless Known.has_key?(key)
      @key = key
    end

    # Human-readable name
    def human; Known[@key][:human];end

    # Directory part to store projects in (inside the Drupal root)
    def dir; Known[@key][:dir]; end

    # The particle to add in the generated package name
    def name_part; Known[@key][:name_part];end

    # Whether to check the tarball structure for this particular project type
    def ck_tar_in_dir?; Known[@key][:ck_tar_in_dir]; end
  end

  class Author
    attr_accessor :name, :user_id, :info_url
    def self.fetch_from(url)
      auth = self.new

      doc = Hpricot(open(url)) or 
        raise IOError, "Could not open author information site at #{url}"
      auth.info_url = url
      auth.name = doc.search('dd[@class="profile-full-name"]').inner_text
      auth.user_id = doc.search('h1[@class="title withtabs"]').inner_text

      auth
    end
  end

  class Project
    attr_accessor :name, :url, :p_type, :descr, :author, :creation, :html
    def initialize(name)
      @name = name
    end

    def fetch_data
      @url = "http://drupal.org/project/#{@name}"
      Logger.instance.debug "Fetching project information from #{@url}"

      @html = Hpricot(open(@url)) or 
        raise IOError, "Could not open #{name} project website at #{@url}"

      # Get the project description. Fetch only the first paragraph -
      # This is usually enough for the .deb, and it should be
      # hand-tuned if needed.
      @descr = (@html.search('div[@class="content"]')[0] / 'p')[0].inner_text

      # When was the project created?
      @creation = Time.parse(@html.search('div[@class="info-page"]').
                             search(':last').inner_text.gsub(/^ - /, ''))
      
      # Project author: We can only get the "first" author (the one
      # that uploaded the node to Drupal, AFAICT). Still, we do what
      # we can.
      relative_url = (@html.search('div[@class="info-page"]')[0] /
                      'a')[0].get_attribute('href').gsub( /^\//, '')
      @author = Author.fetch_from('http://drupal.org/%s' % relative_url)

      # Which kind of project is this? The best way to tell I can come
      # up with is to get it from the last element in the
      # 'breadcrumbs' div
      @p_type = ProjType.new( (@html.search('div[@class="breadcrumb"]')[0] /
                               'a')[-1].inner_text )
      Logger.instance.debug 'Project type for %s: %s' % [@name, 
                                                         @p_type.human]
    end
  end

  # Fetches the list of available versions for a given project, and
  # allows for filtering it to match the user's requested criteria
  class VersionsList < Array
    class UnknownStatus < Exception;end
    attr_accessor :project
    # Builds the list of available versions for the requested project
    def self.for(proj_name)
      list = VersionsList.new
      list.project = Project.new(proj_name)
      list.project.fetch_data
      st_map = {'ok' => :recommended, 'warning' => :supported, 
        'error' => :developer}

      # We do web-scraping, although it is quite fragile, because the
      # RSS feed provided by drupal.org does not show the release's status

      # In the Drupal pages, releases are listed inside <div> elements
      # indicating (via their CSS classes) the status of the contained
      # releases, and a table with the details.
      #
      # We will often get more than one element in releases - "official
      # releases" and "development snapshots" are given as two
      # tables. We should look for the highest (i.e. stablest) release
      # we can get.
      list.project.html.search('div.download-table').
        each do |div|
        div.attributes['class'].split(/\s+/).
          select {|c| c =~ /download-table-(.+)/}
        status = st_map[$1]

        div.search('tr').each do |tr|
          rel = Release.from_tr(tr, status) or next
          rel.project = list.project
          list << rel
        end
      end

      list
    end

    # Returns all the versions available for the given Drupal version
    # for the specified project. The version should be the standard
    # family nomenclature used in Drupal (i.e. '4.7', '5', '6'). The
    # versions are converted to strings for comparison.
    def for_drupal_version(ver)
      self.clone.delete_if {|item| item.drupal_version != ver.to_s}
    end

    # Gives the highest available version for this project available
    # for the specified (first parameter) Drupal version, with the
    # minimum requested stability (second parameter).
    #
    # If no matching versions are found, a EOFError exception will be
    # raised.
    def choose(drupal_ver, min_status)
      Logger.instance.debug(("Going over %d available releases, " +
                             "searching for compatibility with Drupal %s, " +
                             "minimum development status %s (%d)") % 
                            [ self.size, drupal_ver, min_status, 
                              Release::Statuses[min_status] ])

      res = self.for_drupal_version(drupal_ver).with_min_status(min_status).
        sort_by {|item| item.version}
      if res.empty?
        raise EOFError, "No suitable version found for Drupal %s (level>=%s)" %
          [drupal_ver, min_status]
      end
      return res[-1] # Last element: Highest available suitable version
    end

    # Returns all the versions available for the given project which have
    # a stability status at least equal the specified status. The status
    # can be :developer (lowest), :supported or :recommended (highest).
    def with_min_status(min_status)
      statuses = Release::Statuses
      unless min = statuses[min_status.to_sym]
        Logger.instance.error "Unknown status specified. Valid statuses: " +
          statuses.keys.join(', ')
        return nil
      end

      self.clone.delete_if {|item| item.status < min}
    end

    private
    # This class should not be directly initialized from the outside -
    # call VersionsList.for(project) instead
    def initialize
    end
  end

  # Represents the information for any given release of a Drupal project
  class Release
    Statuses = {:developer => 0, :supported => 1, :recommended => 2}
    attr_accessor(:project, :drupal_version, :version, :status, :url, :date)

    # Returns the list of statuses, highest first
    def self.statuses
      Statuses.keys.sort_by {|k| 0 - Statuses[k]}
    end

    # Creates a DrupalProject::Release from a drupal.org table row
    # (yes, heavily dependent on their Web layout). Note that you will
    # still have to explicitly 'give' this Release its project and
    # type once it is created.
    def self.from_tr(tr, status)
      rel = self.new
      rel.status = Statuses[status]

      # We might receive non-interesting (i.e. empty or header)
      # rows. Check first of all if we have version and link strings,
      # and chicken out otherwise.
      columns = tr/'td'
      return nil unless columns[0] and columns[1]

      # We split the full version (first column) into Drupal and
      # project versions
      full_ver = (columns[0]/'a').text
      Logger.instance.debug "Found version %s (%s)" %
        [full_ver, rel.sym_status]
      unless full_ver =~ /^([\d\.]+).x-(.+)$/ 
        Logger.instance.info "cannot parse version #{full_ver} - Ignoring"
        return nil
      end
      rel.drupal_version = $1
      rel.version = mangle($2)

      begin
        rel.date = Time.parse(columns[2].inner_text)
        Logger.instance.debug "This release was uploaded on #{rel.date.to_s}"
      rescue => err
        Logger.instance.warn "Could not parse date «%s» - " +
          "Registering current date" % columns[2]
        rel.date = Time.now
      end

      rel.url = (columns[1]/'a')[0].attributes['href']

      rel
    end

    # Returns the filename to which this release should be saved to
    def dest_file
      '%s_%s.orig.tar.gz' % [ PackageName.for(project.name, project.p_type, 
                                              drupal_version), version]
    end

    # Fetches the this project's released tar.gz, saves it with the
    # filename specified by #dest_file
    def save_file
      Logger.instance.debug "Retreiving remote file #{@url}"
      Logger.instance.debug "Attempting to save in #{dest_file}"
      # Ok, unlinking is not the same as overwriting, except for
      # practical purposes :)
      File.unlink(dest_file) if (File.exists?(dest_file) and 
                                 Options.force_overwrite)
      begin
        if File.exists?(dest_file)
          raise Errno::EEXIST, "Destination filename for source tarball "+
            "(#{dest_file}) already exists. Cannot continue."
        end
        File.open(dest_file, 'w') {|f| f.write open(url).read}
      rescue OpenURI::HTTPError
        Logger.instance.error "Requested URI #{url} could not be retreived"
      end
    end

    # Returns the symbolic status for this revision
    def sym_status
      Statuses.each {|k,v| return k if v == @status}
      nil
    end

    def self.mangle(version)
      return version unless Options.mangle_version
      version.gsub(/\.x[-_.]?(dev)/, '~~\1').gsub(/[-_.]?(alpha|beta|rc)/, '~\1')
    end
  end

  # Reports the progress of the requested operations to the user,
  # according to the minimum severity level specified. Handles four
  # severity levels: Error, Warning, Info and Debug - Respectively, 0,
  # 1, 2 and 3.
  class Logger
    include Singleton
    Levels = %w(E W I D)
    # Private method, not meant to be called directly (this is a
    # singleton object)
    def initialize(level=1)
      @@level = level
    end

    # Redefines the reporting level. If the specified level is below
    # or above the meaningful levels, it will be adjusted to the
    # (respectively) lowest or highest.
    def level=(level)
      l = level.to_i
      l = 0 if l < 0
      l = Levels.size if l > Levels.size
      @@level = l
    end

    # Reports as a message as an error (priority 0). This will always
    # be shown to the user.
    def error(msg); say(0,msg);end
    # Reports the message as a warning (priority 1)
    def warn(msg);  say(1,msg);end
    # Reports the message as informational (priority 2)
    def info(msg);  say(2,msg);end
    # Reports the message as debugging (priority 3)
    def debug(msg); say(3,msg);end

    private
    def say(level, msg)
      puts '%s %s' % [prefix(level), msg] if @@level >= level
    end

    def prefix(level)
      '%s:%s' % [Levels[level], ' '*level]
    end
  end
end

class String
  def word_wrap(maxlen=70)
    self.gsub(/\t/,"     ").gsub(/.{1,#{maxlen}}(?:\s|\Z)/) do 
      ($& + 5.chr).gsub(/\n\005/,"\n").gsub(/\005/,"\n")
    end
  end

  def prefix(with=' ')
    self.split(/\n/).map {|l| '%s%s' % [with, l.empty? ? '.' : l]}.join("\n")
  end
end
