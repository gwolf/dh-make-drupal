#!/usr/bin/ruby
require 'yaml'
require 'commandline'

class App < CommandLine::Application
  def initialize
    version '0.01'
    author 'Gunnar Wolf'
    copyright 'Gunnar Wolf <gwolf@gwolf.org>, IIEc-UNAM 2008'
    short_description 'Builds a Debian package for the requested Drupal project'
    long_description '(...)'

    option :version, :names => %w(--version -v)
    option(:names => %w(--drupal-version -d), 
           :opt_found => get_args,
           :opt_not_found => 6,
           :opt_description => 'Drupal version',
           :arg_description => 'version')
    option :help

    expected_args :project
  end

  def main
    @d_ver = opt['--drupal-version']
    if release = DrupalProjectList.for(@project).choose(@d_ver, :recommended)
      release.save_file
      system "ls -hl #{release.dest_file}"
    else
      puts "No suitable version of #{@project} found for Drupal #{@d_ver}"
      exit 1
    end
  end
end

class DrupalProjectList < Array
  require 'hpricot'
  require 'open-uri'

  def self.for(drup_mod)
    list = DrupalProjectList.new
    url = "http://drupal.org/project/#{drup_mod}"
    doc = Hpricot(open(url)) or 
      raise IOError, "Could not open #{drup_mod} project website at #{url}"

    # In the Drupal pages, releases are listed inside <table
    # class="releases">.
    #
    # We will often get more than one element in releases - "official
    # releases" and "development snapshots" are given as two
    # tables. We should look for the highest (i.e. stablest) release
    # we can get.
    doc.search('table[@class="releases"]').each do |table|
      (table/'tr').each do |tr|
        rel = DrupalProjectRelease.from_tr(tr, drup_mod) or next
        list << rel
      end
    end
    list
  end

  # Returns all the versions available for the given Drupal version
  # for the specified project. The version should be the standard
  # family nomenclature used in Drupal (i.e. '4.7', '5', '6'). The
  # versions are converted to strings for comparison.
  def for_drupal_version(ver)
    self.clone.delete_if {|item| item.drupal_version != ver.to_s}
  end

  def choose(drupal_ver, min_status)
    self.for_drupal_version(drupal_ver).with_min_status(min_status).
      sort_by {|item| item.version}[-1]
  end

  # Returns all the versions available for the given project which have
  # a stability status at least equal the specified status. The status
  # can be :developer (lowest), :supported or :recommended (highest).
  def with_min_status(min_status)
    statuses = DrupalProjectRelease::Statuses
    unless min = statuses[min_status]
      warn "Unknown status specified. Valid statuses: " +
        statuses.keys.join(', ')
      return nil
    end

    self.clone.delete_if {|item| item.status < min}
  end
end

class DrupalProjectRelease
  Statuses = {:developer => 0, :supported => 1, :recommended => 2}
  attr_accessor :project, :drupal_version, :version, :status, :url

  # Creates a DrupalProjectRelease from a drupal.org table row (yes,
  # heavily dependent on their Web layout)
  def self.from_tr(tr, project)
    rel = self.new
    rel.project = project

    # We might receive non-interesting (i.e. empty or header)
    # rows. Check first of all if we have a version string, and
    # chicken out otherwise.
    columns = tr/'td'
    return nil unless columns[0]

    # We get the status from the tr's class - Not very clean IMHO,
    # as it is more visual-related, but we do have the necessary
    # data: It can contain 'ok' (recommended), 'warning' (supported)
    # or 'error' (developer)
    rowclass = tr.attributes['class'].split(/\s+/)
    rel.status = Statuses[:recommended] if rowclass.include? 'ok'
    rel.status = Statuses[:supported] if rowclass.include? 'warning'
    rel.status = Statuses[:developer] if rowclass.include? 'error'

    # We split the full version (first column) into Drupal and
    # project versions
    full_ver = (columns[0]/'a').text
    unless full_ver =~ /^([\d\.]+).x-(.+)$/ 
      warn "cannot parse version #{full_ver} - Ignoring"
      return nil
    end
    rel.drupal_version = $1
    rel.version = $2

    # Column 3 has two URLs - We care about the first one, which
    # points to the file download
    rel.url = (columns[3]/'a')[0].attributes['href']

    rel
  end

  def dest_file
    "drupal%s-%s_%s.orig.tar.gz" % [drupal_version, project, version]
  end

  def save_file
    begin
      if File.exists?(dest_file)
        raise Errno::EEXIST, "Destination filename for source tarball "+
          "(#{dest_file}) already exists. Cannot continue."
      end
      File.open(dest_file, 'w') {|f| f.write open(url).read}
    rescue OpenURI::HTTPError
      puts "Requested URI #{url} could not be retreived"
    end
  end
end
